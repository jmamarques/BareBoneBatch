I'll help you create a GitLab CI pipeline to validate SQL files in your Oracle database project. Here's a comprehensive solution:

1. Basic SQL File Validation Pipeline

Create a .gitlab-ci.yml file in your project root:

```yaml
stages:
  - validation
  - security
  - quality

variables:
  RELEASE_TAG_PATTERN: "^-- Release: v[0-9]+\\.[0-9]+\\.[0-9]+"

# Main validation job
validate_sql_files:
  stage: validation
  image: python:3.9
  before_script:
    - pip install requests
  script:
    - |
      python << 'EOF'
      import os
      import re
      import sys
      
      release_pattern = r"^-- Release: v\d+\.\d+\.\d+"
      sql_files = [f for f in os.listdir('.') if f.endswith('.sql')]
      invalid_files = []
      
      for sql_file in sql_files:
          try:
              with open(sql_file, 'r', encoding='utf-8') as f:
                  first_line = f.readline().strip()
              
              if not re.match(release_pattern, first_line):
                  invalid_files.append(sql_file)
                  print(f"‚ùå {sql_file}: Missing or invalid release tag")
                  print(f"   First line: '{first_line}'")
                  print(f"   Expected format: '-- Release: vX.Y.Z'")
              else:
                  print(f"‚úÖ {sql_file}: Valid release tag found")
                  
          except Exception as e:
              print(f"‚ö†Ô∏è  Error reading {sql_file}: {e}")
              invalid_files.append(sql_file)
      
      if invalid_files:
          print(f"\nüö´ Validation failed for {len(invalid_files)} file(s):")
          for file in invalid_files:
              print(f"   - {file}")
          sys.exit(1)
      else:
          print(f"\nüéâ All {len(sql_files)} SQL files have valid release tags!")
      EOF
  rules:
    - changes:
        - "**/*.sql"
      when: always
    - when: always

# Additional validation: Check SQL syntax
validate_sql_syntax:
  stage: validation
  image: python:3.9
  before_script:
    - pip install sqlparse
  script:
    - |
      python << 'EOF'
      import sqlparse
      import os
      import sys
      
      sql_files = [f for f in os.listdir('.') if f.endswith('.sql')]
      syntax_errors = []
      
      for sql_file in sql_files:
          try:
              with open(sql_file, 'r', encoding='utf-8') as f:
                  content = f.read()
              
              # Basic SQL syntax validation
              parsed = sqlparse.parse(content)
              if not parsed:
                  syntax_errors.append(f"{sql_file}: Empty or invalid SQL")
                  continue
                  
              print(f"‚úÖ {sql_file}: Basic syntax OK")
                  
          except Exception as e:
              syntax_errors.append(f"{sql_file}: {e}")
              print(f"‚ùå {sql_file}: Syntax error - {e}")
      
      if syntax_errors:
          print(f"\nüö´ Syntax validation failed for {len(syntax_errors)} file(s):")
          for error in syntax_errors:
              print(f"   - {error}")
          sys.exit(1)
      EOF
  rules:
    - changes:
        - "**/*.sql"
```

2. Advanced Validation Pipeline

Create additional validation jobs:

```yaml
# Security validation: Check for dangerous patterns
security_scan:
  stage: security
  image: python:3.9
  script:
    - |
      python << 'EOF'
      import os
      import re
      import sys
      
      dangerous_patterns = [
          (r"(?i)DROP\s+(TABLE|DATABASE|USER)", "DROP statements"),
          (r"(?i)DELETE\s+FROM\s+\w+\s+WHERE\s+1=1", "Unconditional DELETE"),
          (r"(?i)UPDATE\s+\w+\s+SET.*WHERE\s+1=1", "Unconditional UPDATE"),
          (r"(?i)ALTER\s+SYSTEM", "ALTER SYSTEM commands"),
          (r"(?i)GRANT\s+ALL", "GRANT ALL privileges"),
      ]
      
      sql_files = [f for f in os.listdir('.') if f.endswith('.sql')]
      security_issues = []
      
      for sql_file in sql_files:
          with open(sql_file, 'r', encoding='utf-8') as f:
              content = f.read()
          
          for pattern, description in dangerous_patterns:
              if re.search(pattern, content, re.IGNORECASE):
                  security_issues.append(f"{sql_file}: Potential security issue - {description}")
                  print(f"‚ö†Ô∏è  {sql_file}: Found {description}")
      
      if security_issues:
          print(f"\nüîí Security issues found in {len(security_issues)} file(s):")
          for issue in security_issues:
              print(f"   - {issue}")
          # Comment out the next line if you want security issues to be warnings only
          # sys.exit(1)
      else:
          print("‚úÖ No security issues found")
      EOF

# File naming convention validation
validate_naming:
  stage: quality
  image: python:3.9
  script:
    - |
      python << 'EOF'
      import os
      import re
      import sys
      
      # Define your naming convention pattern
      naming_pattern = r"^[a-z_]+[a-z0-9_]*\.sql$"
      sql_files = [f for f in os.listdir('.') if f.endswith('.sql')]
      naming_issues = []
      
      for sql_file in sql_files:
          if not re.match(naming_pattern, sql_file.lower()):
              naming_issues.append(sql_file)
              print(f"‚ùå {sql_file}: Doesn't match naming convention")
          else:
              print(f"‚úÖ {sql_file}: Naming convention OK")
      
      if naming_issues:
          print(f"\nüìù Naming convention violations in {len(naming_issues)} file(s):")
          for file in naming_issues:
              print(f"   - {file}")
          # This can be a warning rather than failure
          # sys.exit(1)
      EOF

# File size validation
validate_file_size:
  stage: quality
  image: python:3.9
  script:
    - |
      python << 'EOF'
      import os
      import sys
      
      MAX_FILE_SIZE_KB = 100  # Adjust as needed
      sql_files = [f for f in os.listdir('.') if f.endswith('.sql')]
      oversized_files = []
      
      for sql_file in sql_files:
          size_kb = os.path.getsize(sql_file) / 1024
          if size_kb > MAX_FILE_SIZE_KB:
              oversized_files.append((sql_file, size_kb))
              print(f"‚ö†Ô∏è  {sql_file}: {size_kb:.1f}KB (max: {MAX_FILE_SIZE_KB}KB)")
          else:
              print(f"‚úÖ {sql_file}: {size_kb:.1f}KB")
      
      if oversized_files:
          print(f"\nüìè {len(oversized_files)} file(s) exceed size limit:")
          for file, size in oversized_files:
              print(f"   - {file}: {size:.1f}KB")
          # Comment out next line if you want this to be a warning
          # sys.exit(1)
      EOF
```

3. Oracle-Specific Validation

```yaml
# Oracle-specific validation
oracle_validation:
  stage: validation
  image: python:3.9
  before_script:
    - pip install oracledb
  script:
    - |
      python << 'EOF'
      import os
      import re
      import sys
      
      # Check for Oracle-specific issues
      oracle_issues = []
      sql_files = [f for f in os.listdir('.') if f.endswith('.sql')]
      
      oracle_reserved_words = [
          'SYSDATE', 'DUAL', 'ROWNUM', 'ROWID', 'NVL', 'DECODE',
          'LEVEL', 'CONNECT_BY_ROOT', 'PRIOR'
      ]
      
      for sql_file in sql_files:
          with open(sql_file, 'r', encoding='utf-8') as f:
              content = f.read().upper()
          
          # Check for potential issues
          if 'SELECT *' in content:
              oracle_issues.append(f"{sql_file}: Uses SELECT * - specify columns explicitly")
          
          # Check for missing semicolons in multi-statement files
          statements = [s.strip() for s in content.split(';') if s.strip()]
          if len(statements) > 1 and not content.strip().endswith(';'):
              oracle_issues.append(f"{sql_file}: Missing semicolon at end of file")
          
          print(f"üîç {sql_file}: Oracle-specific checks completed")
      
      if oracle_issues:
          print(f"\nüêõ Oracle-specific issues found:")
          for issue in oracle_issues:
              print(f"   - {issue}")
          # Uncomment to fail pipeline on Oracle issues
          # sys.exit(1)
      else:
          print("‚úÖ No Oracle-specific issues found")
      EOF
  only:
    changes:
      - "**/*.sql"
```

4. Complete Pipeline with Customizable Variables

```yaml
# Complete .gitlab-ci.yml
stages:
  - validation
  - security
  - quality
  - notify

variables:
  RELEASE_TAG_PATTERN: "^-- Release: v[0-9]+\\.[0-9]+\\.[0-9]+"
  MAX_FILE_SIZE_KB: "100"
  FAIL_ON_SECURITY_ISSUES: "false"
  FAIL_ON_NAMING_ISSUES: "false"

.validate_script: &validate_script |
  import os, re, sys
  release_pattern = r"${RELEASE_TAG_PATTERN}"
  sql_files = [f for f in os.listdir('.') if f.endswith('.sql')]
  invalid_files = []
  
  for sql_file in sql_files:
      try:
          with open(sql_file, 'r') as f:
              first_line = f.readline().strip()
          if not re.match(release_pattern, first_line):
              invalid_files.append(sql_file)
              print(f"‚ùå {sql_file}: Missing release tag")
      except Exception as e:
          print(f"Error: {e}")
          invalid_files.append(sql_file)
  
  if invalid_files:
      print(f"Failed for: {invalid_files}")
      sys.exit(1)
  else:
      print("All SQL files validated successfully!")

validate_sql_files:
  stage: validation
  image: python:3.9
  script:
    - python -c *validate_script

# Notification job (optional)
notify_validation_success:
  stage: notify
  image: alpine:latest
  script:
    - echo "All SQL validations passed successfully!"
    - echo "Release tags are properly formatted in all .sql files"
  needs:
    - validate_sql_files
    - validate_sql_syntax
  only:
    - main
    - master
  when: on_success

notify_validation_failure:
  stage: notify
  image: alpine:latest
  script:
    - echo "SQL validation failed! Please check the pipeline logs."
  needs:
    - validate_sql_files
  when: on_failure
```

5. Example SQL File Template

Create an example SQL file that passes validation:

```sql
-- Release: v1.0.0
-- Description: Example SQL file with proper release tag
-- Author: Your Name
-- Date: 2024-01-01

/* 
   Your Oracle SQL code here
   This file will pass all validations
*/

CREATE TABLE example_table (
    id NUMBER PRIMARY KEY,
    name VARCHAR2(100) NOT NULL,
    created_date DATE DEFAULT SYSDATE
);

-- Add your SQL statements below
```

Usage Instructions

1. Place the .gitlab-ci.yml file in your project root
2. Adjust the variables according to your needs:
   ¬∑ RELEASE_TAG_PATTERN: Modify the regex to match your release tag format
   ¬∑ MAX_FILE_SIZE_KB: Set appropriate file size limits
3. Configure the failure conditions by uncommenting the sys.exit(1) lines in jobs where you want strict validation
4. Add Oracle connection validation if you have database credentials available in CI variables

This pipeline will:

¬∑ ‚úÖ Fail if SQL files don't start with the required release tag
¬∑ ‚úÖ Validate SQL syntax
¬∑ ‚úÖ Check for security issues
¬∑ ‚úÖ Validate naming conventions
¬∑ ‚úÖ Check file sizes
¬∑ ‚úÖ Perform Oracle-specific validations

The pipeline runs automatically when SQL files are modified and provides clear feedback about any validation failures.


I'll modify the pipeline to validate only new SQL files and files changed in the current commit/merge request. Here's the updated configuration:

GitLab CI Pipeline for Changed Files Only

```yaml
stages:
  - validation

variables:
  RELEASE_TAG_PATTERN: "^-- Release: v[0-9]+\\.[0-9]+\\.[0-9]+"

validate_changed_sql_files:
  stage: validation
  image: python:3.9
  before_script:
    - pip install sqlparse
  script:
    - |
      python << 'EOF'
      import os
      import re
      import sys
      import sqlparse
      import subprocess
      
      # Basic filename pattern (adjust as needed)
      FILENAME_PATTERN = r'^[a-z][a-z0-9_]*\.sql$'
      release_pattern = r"^-- Release: v\d+\.\d+\.\d+"
      
      def get_changed_files():
          """Get list of changed SQL files in the current commit/MR"""
          try:
              # For merge requests
              if os.environ.get('CI_MERGE_REQUEST_IID'):
                  result = subprocess.run([
                      'git', 'diff', '--name-only', 
                      '--diff-filter=AM', 
                      f"origin/{os.environ.get('CI_MERGE_REQUEST_TARGET_BRANCH_NAME', 'main')}...HEAD"
                  ], capture_output=True, text=True, check=True)
              # For branch pipelines
              elif os.environ.get('CI_COMMIT_BEFORE_SHA') and os.environ.get('CI_COMMIT_BEFORE_SHA') != '0000000000000000000000000000000000000000':
                  result = subprocess.run([
                      'git', 'diff', '--name-only', 
                      '--diff-filter=AM',
                      os.environ.get('CI_COMMIT_BEFORE_SHA'), 
                      os.environ.get('CI_COMMIT_SHA')
                  ], capture_output=True, text=True, check=True)
              # For initial commit (no previous commit)
              else:
                  result = subprocess.run([
                      'git', 'show', '--name-only', '--pretty=format:', 'HEAD'
                  ], capture_output=True, text=True, check=True)
              
              changed_files = result.stdout.strip().split('\n')
              return [f for f in changed_files if f.endswith('.sql')]
              
          except subprocess.CalledProcessError as e:
              print(f"Error getting changed files: {e}")
              return []
          except Exception as e:
              print(f"Unexpected error: {e}")
              return []
      
      def validate_sql_file(sql_file):
          """Validate a single SQL file"""
          print(f"üìÑ Validating: {sql_file}")
          file_errors = []
          
          # Check if file exists (it should for new/modified files)
          if not os.path.exists(sql_file):
              file_errors.append("File not found in current commit")
              return file_errors
          
          # 1. Check release tag
          try:
              with open(sql_file, 'r', encoding='utf-8') as f:
                  first_line = f.readline().strip()
              
              if not re.match(release_pattern, first_line):
                  file_errors.append(f"Missing or invalid release tag. First line: '{first_line}'")
                  print(f"   ‚ùå Release tag: Invalid")
              else:
                  print(f"   ‚úÖ Release tag: {first_line}")
          except Exception as e:
              file_errors.append(f"Error reading file: {e}")
          
          # 2. Validate filename convention
          filename = os.path.basename(sql_file)
          if not re.match(FILENAME_PATTERN, filename, re.IGNORECASE):
              file_errors.append(f"Filename doesn't match pattern: {FILENAME_PATTERN}")
              print(f"   ‚ùå Filename convention: Invalid")
          else:
              print(f"   ‚úÖ Filename convention: OK")
          
          # 3. Validate SQL syntax
          try:
              with open(sql_file, 'r', encoding='utf-8') as f:
                  content = f.read()
              
              # Skip empty files
              if content.strip():
                  parsed = sqlparse.parse(content)
                  if not parsed:
                      file_errors.append("Invalid SQL syntax - cannot parse")
                      print(f"   ‚ùå SQL syntax: Invalid")
                  else:
                      print(f"   ‚úÖ SQL syntax: OK")
              else:
                  print(f"   ‚ö†Ô∏è  SQL syntax: Empty file")
                  
          except Exception as e:
              file_errors.append(f"SQL syntax error: {str(e)}")
              print(f"   ‚ùå SQL syntax: Error")
          
          return file_errors
      
      # Main execution
      changed_sql_files = get_changed_files()
      
      if not changed_sql_files:
          print("‚úÖ No SQL files changed in this commit/merge request")
          sys.exit(0)
      
      print(f"üîç Found {len(changed_sql_files)} changed SQL files to validate\n")
      
      validation_errors = []
      for sql_file in changed_sql_files:
          file_errors = validate_sql_file(sql_file)
          if file_errors:
              validation_errors.append({
                  'file': sql_file,
                  'errors': file_errors
              })
          print()
      
      # Print summary
      if validation_errors:
          print("üö´ VALIDATION FAILED")
          print("=" * 50)
          for error_info in validation_errors:
              print(f"\nüìÅ {error_info['file']}")
              for error in error_info['errors']:
                  print(f"   ‚ùå {error}")
          
          print(f"\n‚ùå Validation failed for {len(validation_errors)} file(s)")
          sys.exit(1)
      else:
          print("üéâ ALL VALIDATIONS PASSED!")
          print(f"‚úÖ Successfully validated {len(changed_sql_files)} changed SQL files")
      EOF
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH
```

Alternative: Simpler Git Diff Approach

```yaml
stages:
  - validation

variables:
  RELEASE_TAG_PATTERN: "^-- Release: v[0-9]+\\.[0-9]+\\.[0-9]+"

validate_changed_sql:
  stage: validation
  image: python:3.9
  before_script:
    - pip install sqlparse
  script:
    - |
      python << 'EOF'
      import os
      import re
      import sys
      import sqlparse
      
      FILENAME_PATTERN = r'^[a-z][a-z0-9_]*\.sql$'
      release_pattern = r"^-- Release: v\d+\.\d+\.\d+"
      
      # Get changed files using GitLab CI environment variables
      changed_files = []
      
      # Method 1: Check CI_COMMIT_BEFORE_SHA to CI_COMMIT_SHA (pushes)
      if os.environ.get('CI_COMMIT_BEFORE_SHA') and os.environ.get('CI_COMMIT_BEFORE_SHA') != '0000000000000000000000000000000000000000':
          import subprocess
          result = subprocess.run([
              'git', 'diff', '--name-only', '--diff-filter=AM',
              os.environ['CI_COMMIT_BEFORE_SHA'], os.environ['CI_COMMIT_SHA']
          ], capture_output=True, text=True)
          changed_files = [f for f in result.stdout.strip().split('\n') if f.endswith('.sql')]
      
      # Method 2: For merge requests, check changed files in MR
      elif os.environ.get('CI_MERGE_REQUEST_CHANGED_FILES'):
          # This requires GitLab 13.4+ and appropriate CI variables setup
          changed_files = [f for f in os.environ.get('CI_MERGE_REQUEST_CHANGED_FILES', '').split(' ') if f.endswith('.sql')]
      
      # Method 3: Fallback - check all SQL files in latest commit
      else:
          import subprocess
          result = subprocess.run([
              'git', 'show', '--name-only', '--pretty=format:', 'HEAD'
          ], capture_output=True, text=True)
          changed_files = [f for f in result.stdout.strip().split('\n') if f.endswith('.sql')]
      
      if not changed_files:
          print("‚úÖ No SQL files changed in this commit")
          sys.exit(0)
      
      print(f"üîç Validating {len(changed_files)} changed SQL file(s): {', '.join(changed_files)}\n")
      
      validation_errors = []
      for sql_file in changed_files:
          if not os.path.exists(sql_file):
              print(f"‚ö†Ô∏è  File {sql_file} not found, skipping")
              continue
              
          print(f"üìÑ Validating: {sql_file}")
          file_errors = []
          
          # Release tag check
          with open(sql_file, 'r') as f:
              first_line = f.readline().strip()
          if not re.match(release_pattern, first_line):
              file_errors.append(f"Invalid release tag: '{first_line}'")
          
          # Filename convention
          filename = os.path.basename(sql_file)
          if not re.match(FILENAME_PATTERN, filename, re.IGNORECASE):
              file_errors.append(f"Filename doesn't match pattern")
          
          # SQL syntax
          try:
              with open(sql_file, 'r') as f:
                  content = f.read()
              if content.strip() and not sqlparse.parse(content):
                  file_errors.append("SQL syntax error")
          except Exception as e:
              file_errors.append(f"SQL parsing error: {e}")
          
          if file_errors:
              validation_errors.append({'file': sql_file, 'errors': file_errors})
              for error in file_errors:
                  print(f"   ‚ùå {error}")
          else:
              print(f"   ‚úÖ All checks passed")
          print()
      
      if validation_errors:
          print(f"üö´ Validation failed for {len(validation_errors)} file(s)")
          sys.exit(1)
      else:
          print("üéâ All changed SQL files validated successfully!")
      EOF
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
      changes:
        - "**/*.sql"
    - if: $CI_COMMIT_BRANCH
      changes:
        - "**/*.sql"
```

GitLab CI Configuration for Merge Requests

To ensure this runs properly on merge requests, you might need to add this to your .gitlab-ci.yml:

```yaml
workflow:
  rules:
    - if: $CI_MERGE_REQUEST_IID
    - if: $CI_COMMIT_TAG
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    - if: $CI_COMMIT_BRANCH
```

Key Features:

1. Targets Only Changed Files: Only validates SQL files that were added or modified in the current commit/merge request
2. Merge Request Support: Works with both branch pushes and merge requests
3. Efficient: Doesn't waste time validating unchanged files
4. Clear Context: Shows exactly which files are being validated and why

How It Works:

¬∑ For Merge Requests: Compares the feature branch with the target branch to find changed SQL files
¬∑ For Branch Pushes: Uses git diff between the previous commit and current commit
¬∑ For Initial Commits: Falls back to checking all files in the current commit

The pipeline will only run when SQL files are changed and will only validate those specific files, making your CI process much faster and more focused.