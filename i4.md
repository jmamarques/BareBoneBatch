Here's the implementation without Docker, Prometheus, or Grafana, using MyBatis and .properties configuration:

üìä 1. Dependencies Configuration

pom.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0">
    <dependencies>
        <!-- Spring Boot Actuator -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>
        
        <!-- Micrometer Core -->
        <dependency>
            <groupId>io.micrometer</groupId>
            <artifactId>micrometer-core</artifactId>
        </dependency>
        
        <!-- Spring Batch -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-batch</artifactId>
        </dependency>
        
        <!-- MyBatis -->
        <dependency>
            <groupId>org.mybatis.spring.boot</groupId>
            <artifactId>mybatis-spring-boot-starter</artifactId>
            <version>2.3.1</version>
        </dependency>
        
        <!-- Oracle JDBC -->
        <dependency>
            <groupId>com.oracle.database.jdbc</groupId>
            <artifactId>ojdbc8</artifactId>
            <version>21.5.0.0</version>
        </dependency>
    </dependencies>
</project>
```

‚öôÔ∏è 2. Application Configuration (.properties)

application.properties

```properties
# Application
server.port=8080
spring.application.name=batch-monitoring-demo

# Actuator Configuration
management.endpoints.web.exposure.include=health,metrics,info,batch,jobs
management.endpoint.health.show-details=always
management.endpoint.metrics.enabled=true
management.endpoint.batch.enabled=true
management.endpoint.jobs.enabled=true
management.metrics.tags.application=batch-service
management.metrics.tags.environment=dev

# Database Configuration (Oracle)
spring.datasource.url=jdbc:oracle:thin:@localhost:1521:XE
spring.datasource.username=batch_user
spring.datasource.password=batch_pass
spring.datasource.driver-class-name=oracle.jdbc.OracleDriver

# MyBatis Configuration
mybatis.mapper-locations=classpath:mappers/*.xml
mybatis.type-aliases-package=com.example.batch.entity
mybatis.configuration.map-underscore-to-camel-case=true

# Spring Batch Configuration
spring.batch.job.enabled=false
spring.batch.jdbc.initialize-schema=always
spring.batch.table-prefix=BATCH_

# Hikari Connection Pool
spring.datasource.hikari.maximum-pool-size=20
spring.datasource.hikari.minimum-idle=5
spring.datasource.hikari.connection-timeout=30000
spring.datasource.hikari.idle-timeout=300000
spring.datasource.hikari.max-lifetime=1200000

# Logging
logging.level.com.example.batch=DEBUG
logging.level.org.springframework.batch=INFO
logging.level.org.mybatis=DEBUG

# Custom Metrics
monitoring.metrics.prefix=batch
monitoring.metrics.enabled=true
```

üîß 3. MyBatis Configuration

MyBatisConfig.java

```java
@Configuration
@MapperScan("com.example.batch.mapper")
public class MyBatisConfig {
    
    @Bean
    public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
        SqlSessionFactoryBean sessionFactory = new SqlSessionFactoryBean();
        sessionFactory.setDataSource(dataSource);
        
        // MyBatis configuration
        org.apache.ibatis.session.Configuration configuration = 
            new org.apache.ibatis.session.Configuration();
        configuration.setMapUnderscoreToCamelCase(true);
        configuration.setCacheEnabled(false);
        configuration.setUseGeneratedKeys(true);
        configuration.setDefaultStatementTimeout(30);
        
        sessionFactory.setConfiguration(configuration);
        
        return sessionFactory.getObject();
    }
    
    @Bean
    public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
        return new SqlSessionTemplate(sqlSessionFactory);
    }
}
```

üìà 4. Comprehensive Batch Metrics Service

CustomBatchMetricsService.java

```java
@Component
public class CustomBatchMetricsService {
    
    private final MeterRegistry meterRegistry;
    
    // Counters
    private final Counter totalJobsCounter;
    private final Counter totalStepsCounter;
    private final Counter itemsProcessedCounter;
    private final Counter itemsReadCounter;
    private final Counter itemsWrittenCounter;
    private final Counter skipCounter;
    private final Counter errorCounter;
    
    // Timers
    private final Timer jobExecutionTimer;
    private final Timer stepExecutionTimer;
    private final Timer chunkProcessingTimer;
    
    // Gauges
    private final AtomicLong activeJobs = new AtomicLong(0);
    private final AtomicLong activeSteps = new AtomicLong(0);
    
    @Autowired
    public CustomBatchMetricsService(MeterRegistry meterRegistry) {
        this.meterRegistry = meterRegistry;
        
        // Initialize counters
        this.totalJobsCounter = Counter.builder("batch.jobs.total")
                .description("Total number of jobs executed")
                .register(meterRegistry);
                
        this.totalStepsCounter = Counter.builder("batch.steps.total")
                .description("Total number of steps executed")
                .register(meterRegistry);
                
        this.itemsProcessedCounter = Counter.builder("batch.items.processed")
                .description("Total number of items processed")
                .register(meterRegistry);
                
        this.itemsReadCounter = Counter.builder("batch.items.read")
                .description("Total number of items read")
                .register(meterRegistry);
                
        this.itemsWrittenCounter = Counter.builder("batch.items.written")
                .description("Total number of items written")
                .register(meterRegistry);
                
        this.skipCounter = Counter.builder("batch.items.skipped")
                .description("Total number of items skipped")
                .register(meterRegistry);
                
        this.errorCounter = Counter.builder("batch.errors.total")
                .description("Total number of errors")
                .register(meterRegistry);
        
        // Initialize timers
        this.jobExecutionTimer = Timer.builder("batch.job.execution.time")
                .description("Time taken for job execution")
                .register(meterRegistry);
                
        this.stepExecutionTimer = Timer.builder("batch.step.execution.time")
                .description("Time taken for step execution")
                .register(meterRegistry);
                
        this.chunkProcessingTimer = Timer.builder("batch.chunk.processing.time")
                .description("Time taken for chunk processing")
                .register(meterRegistry);
        
        // Initialize gauges
        Gauge.builder("batch.jobs.active", activeJobs, AtomicLong::get)
                .description("Number of currently active jobs")
                .register(meterRegistry);
                
        Gauge.builder("batch.steps.active", activeSteps, AtomicLong::get)
                .description("Number of currently active steps")
                .register(meterRegistry);
    }
    
    // Job metrics
    public void incrementJobCount(String jobName) {
        totalJobsCounter.increment();
        
        Counter.builder("batch.jobs.by.name")
                .tag("jobName", jobName)
                .register(meterRegistry)
                .increment();
    }
    
    public Timer.Sample startJobExecutionTimer() {
        activeJobs.incrementAndGet();
        return Timer.start(meterRegistry);
    }
    
    public void stopJobExecutionTimer(Timer.Sample sample, String jobName, String status) {
        activeJobs.decrementAndGet();
        sample.stop(Timer.builder("batch.job.execution.duration")
                .tag("jobName", jobName)
                .tag("status", status)
                .register(meterRegistry));
    }
    
    // Step metrics
    public void incrementStepCount(String stepName) {
        totalStepsCounter.increment();
        activeSteps.incrementAndGet();
        
        Counter.builder("batch.steps.by.name")
                .tag("stepName", stepName)
                .register(meterRegistry)
                .increment();
    }
    
    public Timer.Sample startStepExecutionTimer() {
        return Timer.start(meterRegistry);
    }
    
    public void stopStepExecutionTimer(Timer.Sample sample, String stepName, String status) {
        activeSteps.decrementAndGet();
        sample.stop(Timer.builder("batch.step.execution.duration")
                .tag("stepName", stepName)
                .tag("status", status)
                .register(meterRegistry));
    }
    
    // Item processing metrics
    public void incrementItemsProcessed(int count, String stepName) {
        itemsProcessedCounter.increment(count);
        
        Counter.builder("batch.items.processed.by.step")
                .tag("stepName", stepName)
                .register(meterRegistry)
                .increment(count);
    }
    
    public void incrementItemsRead(int count, String stepName) {
        itemsReadCounter.increment(count);
    }
    
    public void incrementItemsWritten(int count, String stepName) {
        itemsWrittenCounter.increment(count);
    }
    
    // Error and skip metrics
    public void incrementSkipCount(String stepName, String skipType) {
        skipCounter.increment();
        
        Counter.builder("batch.items.skipped.by.type")
                .tag("stepName", stepName)
                .tag("skipType", skipType)
                .register(meterRegistry)
                .increment();
    }
    
    public void incrementErrorCount(String stepName, String errorType) {
        errorCounter.increment();
        
        Counter.builder("batch.errors.by.type")
                .tag("stepName", stepName)
                .tag("errorType", errorType)
                .register(meterRegistry)
                .increment();
    }
    
    // Chunk processing metrics
    public Timer.Sample startChunkProcessingTimer() {
        return Timer.start(meterRegistry);
    }
    
    public void stopChunkProcessingTimer(Timer.Sample sample, String stepName, int chunkSize) {
        sample.stop(Timer.builder("batch.chunk.processing.duration")
                .tag("stepName", stepName)
                .tag("chunkSize", String.valueOf(chunkSize))
                .register(meterRegistry));
    }
    
    // Memory metrics
    public void recordMemoryUsage() {
        Runtime runtime = Runtime.getRuntime();
        long usedMemory = runtime.totalMemory() - runtime.freeMemory();
        long maxMemory = runtime.maxMemory();
        
        meterRegistry.gauge("batch.memory.used.bytes", usedMemory);
        meterRegistry.gauge("batch.memory.max.bytes", maxMemory);
        meterRegistry.gauge("batch.memory.usage.percent", 
                (double) usedMemory / maxMemory * 100);
    }
}
```

üéØ 5. MyBatis Mappers for Metrics

BatchMetricsMapper.java

```java
@Mapper
public interface BatchMetricsMapper {
    
    @Select("SELECT COUNT(*) FROM BATCH_JOB_INSTANCE WHERE JOB_NAME = #{jobName}")
    int countJobInstancesByName(@Param("jobName") String jobName);
    
    @Select("SELECT COUNT(*) FROM BATCH_JOB_EXECUTION WHERE STATUS = #{status}")
    int countJobExecutionsByStatus(@Param("status") String status);
    
    @Select("SELECT JOB_NAME, STATUS, COUNT(*) as count " +
            "FROM BATCH_JOB_EXECUTION je " +
            "JOIN BATCH_JOB_INSTANCE ji ON je.JOB_INSTANCE_ID = ji.JOB_INSTANCE_ID " +
            "GROUP BY JOB_NAME, STATUS")
    @Results({
        @Result(property = "jobName", column = "JOB_NAME"),
        @Result(property = "status", column = "STATUS"),
        @Result(property = "count", column = "count")
    })
    List<JobStatusCount> getJobStatusCounts();
    
    @Select("SELECT STEP_NAME, STATUS, AVG((END_TIME - START_TIME) * 86400) as avg_duration_seconds " +
            "FROM BATCH_STEP_EXECUTION " +
            "WHERE END_TIME IS NOT NULL AND START_TIME IS NOT NULL " +
            "GROUP BY STEP_NAME, STATUS")
    @Results({
        @Result(property = "stepName", column = "STEP_NAME"),
        @Result(property = "status", column = "STATUS"),
        @Result(property = "avgDurationSeconds", column = "avg_duration_seconds")
    })
    List<StepDuration> getStepDurations();
    
    @Select("SELECT JOB_NAME, START_TIME, END_TIME, STATUS, EXIT_CODE " +
            "FROM BATCH_JOB_EXECUTION je " +
            "JOIN BATCH_JOB_INSTANCE ji ON je.JOB_INSTANCE_ID = ji.JOB_INSTANCE_ID " +
            "ORDER BY START_TIME DESC " +
            "FETCH FIRST 50 ROWS ONLY")
    @Results({
        @Result(property = "jobName", column = "JOB_NAME"),
        @Result(property = "startTime", column = "START_TIME"),
        @Result(property = "endTime", column = "END_TIME"),
        @Result(property = "status", column = "STATUS"),
        @Result(property = "exitCode", column = "EXIT_CODE")
    })
    List<JobExecutionHistory> getRecentJobExecutions();
}

// DTO classes
class JobStatusCount {
    private String jobName;
    private String status;
    private int count;
    // getters and setters
}

class StepDuration {
    private String stepName;
    private String status;
    private double avgDurationSeconds;
    // getters and setters
}

class JobExecutionHistory {
    private String jobName;
    private Date startTime;
    private Date endTime;
    private String status;
    private String exitCode;
    // getters and setters
}
```

üìä 6. Batch Execution Listeners with Metrics

MetricsJobExecutionListener.java

```java
@Component
public class MetricsJobExecutionListener implements JobExecutionListener {
    
    @Autowired
    private CustomBatchMetricsService metricsService;
    
    private final ThreadLocal<Timer.Sample> jobTimer = new ThreadLocal<>();
    private final ThreadLocal<String> jobName = new ThreadLocal<>();
    
    @Override
    public void beforeJob(JobExecution jobExecution) {
        String name = jobExecution.getJobInstance().getJobName();
        jobName.set(name);
        jobTimer.set(metricsService.startJobExecutionTimer());
        metricsService.incrementJobCount(name);
        
        System.out.println("Starting job: " + name);
    }
    
    @Override
    public void afterJob(JobExecution jobExecution) {
        String name = jobName.get();
        String status = jobExecution.getStatus().toString();
        
        metricsService.stopJobExecutionTimer(jobTimer.get(), name, status);
        
        // Record job-level metrics
        metricsService.recordMemoryUsage();
        
        System.out.printf("Completed job: %s with status: %s%n", name, status);
        
        // Cleanup
        jobTimer.remove();
        jobName.remove();
    }
}
```

MetricsStepExecutionListener.java

```java
@Component
public class MetricsStepExecutionListener implements StepExecutionListener {
    
    @Autowired
    private CustomBatchMetricsService metricsService;
    
    private final ThreadLocal<Timer.Sample> stepTimer = new ThreadLocal<>();
    private final ThreadLocal<String> stepName = new ThreadLocal<>();
    
    @Override
    public void beforeStep(StepExecution stepExecution) {
        String name = stepExecution.getStepName();
        stepName.set(name);
        stepTimer.set(metricsService.startStepExecutionTimer());
        metricsService.incrementStepCount(name);
        
        System.out.println("Starting step: " + name);
    }
    
    @Override
    public ExitStatus afterStep(StepExecution stepExecution) {
        String name = stepName.get();
        String status = stepExecution.getStatus().toString();
        
        metricsService.stopStepExecutionTimer(stepTimer.get(), name, status);
        
        // Record step metrics
        metricsService.incrementItemsRead(stepExecution.getReadCount(), name);
        metricsService.incrementItemsWritten(stepExecution.getWriteCount(), name);
        metricsService.incrementItemsProcessed(stepExecution.getWriteCount(), name);
        
        // Record skips
        if (stepExecution.getReadSkipCount() > 0) {
            metricsService.incrementSkipCount(name, "READ");
        }
        if (stepExecution.getProcessSkipCount() > 0) {
            metricsService.incrementSkipCount(name, "PROCESS");
        }
        if (stepExecution.getWriteSkipCount() > 0) {
            metricsService.incrementSkipCount(name, "WRITE");
        }
        
        System.out.printf("Completed step: %s, Read: %d, Written: %d, Skips: %d%n",
                name, stepExecution.getReadCount(), stepExecution.getWriteCount(),
                stepExecution.getSkipCount());
        
        // Cleanup
        stepTimer.remove();
        stepName.remove();
        
        return stepExecution.getExitStatus();
    }
}
```

üìù 7. Custom Health Checks with MyBatis

BatchHealthIndicator.java

```java
@Component
public class BatchHealthIndicator implements HealthIndicator {
    
    @Autowired
    private BatchMetricsMapper batchMetricsMapper;
    
    @Autowired
    private DataSource dataSource;
    
    private static final int MAX_FAILED_JOBS = 10;
    
    @Override
    public Health health() {
        try {
            List<String> issues = new ArrayList<>();
            
            // Check for failed jobs using MyBatis
            checkFailedJobs(issues);
            
            // Check database connectivity
            checkDatabase(issues);
            
            // Check batch tables existence
            checkBatchTables(issues);
            
            if (issues.isEmpty()) {
                return Health.up()
                        .withDetail("message", "Batch system is healthy")
                        .withDetail("database", "Connected to Oracle")
                        .withDetail("batchTables", "All tables accessible")
                        .build();
            } else {
                return Health.down()
                        .withDetail("message", "Batch system has issues")
                        .withDetail("issues", issues)
                        .build();
            }
            
        } catch (Exception e) {
            return Health.down(e).build();
        }
    }
    
    private void checkFailedJobs(List<String> issues) {
        try {
            int failedJobsCount = batchMetricsMapper.countJobExecutionsByStatus("FAILED");
            if (failedJobsCount > MAX_FAILED_JOBS) {
                issues.add(String.format("Too many failed jobs: %d", failedJobsCount));
            }
        } catch (Exception e) {
            issues.add("Cannot query failed jobs: " + e.getMessage());
        }
    }
    
    private void checkDatabase(List<String> issues) {
        try {
            dataSource.getConnection().close();
        } catch (SQLException e) {
            issues.add("Database connectivity issue: " + e.getMessage());
        }
    }
    
    private void checkBatchTables(List<String> issues) {
        try {
            // This will throw exception if batch tables don't exist
            batchMetricsMapper.countJobInstancesByName("test");
        } catch (Exception e) {
            issues.add("Batch tables issue: " + e.getMessage());
        }
    }
}
```

üåê 8. Metrics Controller & API

MetricsController.java

```java
@RestController
@RequestMapping("/api/metrics")
public class MetricsController {
    
    @Autowired
    private MeterRegistry meterRegistry;
    
    @Autowired
    private BatchMetricsMapper batchMetricsMapper;
    
    @Autowired
    private CustomBatchMetricsService metricsService;
    
    @GetMapping("/batch/summary")
    public Map<String, Object> getBatchSummary() {
        Map<String, Object> summary = new HashMap<>();
        
        try {
            // Get job statistics from database
            List<JobStatusCount> jobStatusCounts = batchMetricsMapper.getJobStatusCounts();
            
            summary.put("jobStatusCounts", jobStatusCounts);
            summary.put("recentExecutions", batchMetricsMapper.getRecentJobExecutions());
            summary.put("stepDurations", batchMetricsMapper.getStepDurations());
            
        } catch (Exception e) {
            summary.put("error", "Failed to retrieve batch summary: " + e.getMessage());
        }
        
        return summary;
    }
    
    @GetMapping("/custom")
    public Map<String, Object> getCustomMetrics() {
        Map<String, Object> customMetrics = new HashMap<>();
        
        // Collect custom metrics from Micrometer
        meterRegistry.getMeters().forEach(meter -> {
            String meterName = meter.getId().getName();
            if (meterName.startsWith("batch.")) {
                customMetrics.put(meterName, getMeterValue(meter));
            }
        });
        
        // Add memory information
        Runtime runtime = Runtime.getRuntime();
        customMetrics.put("memory.used", runtime.totalMemory() - runtime.freeMemory());
        customMetrics.put("memory.max", runtime.maxMemory());
        customMetrics.put("memory.free", runtime.freeMemory());
        
        return customMetrics;
    }
    
    @GetMapping("/health/detailed")
    public Map<String, Object> getDetailedHealth() {
        Map<String, Object> healthInfo = new HashMap<>();
        
        healthInfo.put("timestamp", new Date());
        healthInfo.put("application", "Batch Monitoring Service");
        
        // Memory info
        Runtime runtime = Runtime.getRuntime();
        healthInfo.put("memoryUsedMB", (runtime.totalMemory() - runtime.freeMemory()) / 1024 / 1024);
        healthInfo.put("memoryMaxMB", runtime.maxMemory() / 1024 / 1024);
        healthInfo.put("memoryFreeMB", runtime.freeMemory() / 1024 / 1024);
        
        // Thread info
        healthInfo.put("threadCount", Thread.activeCount());
        
        return healthInfo;
    }
    
    private Object getMeterValue(Meter meter) {
        if (meter instanceof Counter) {
            return ((Counter) meter).count();
        } else if (meter instanceof Timer) {
            return ((Timer) meter).totalTime(TimeUnit.MILLISECONDS);
        } else if (meter instanceof Gauge) {
            return ((Gauge) meter).value();
        }
        return null;
    }
}
```

üöÄ 9. Batch Configuration with MyBatis

BatchConfig.java

```java
@Configuration
@EnableBatchProcessing
public class BatchConfig {
    
    @Autowired
    private MetricsJobExecutionListener jobMetricsListener;
    
    @Autowired
    private MetricsStepExecutionListener stepMetricsListener;
    
    @Bean
    public Job dataProcessingJob(Step processingStep) {
        return jobBuilderFactory.get("dataProcessingJob")
                .incrementer(new RunIdIncrementer())
                .start(processingStep)
                .listener(jobMetricsListener)
                .build();
    }
    
    @Bean
    @StepScope
    public MyBatisCursorItemReader<ImportLine> importLineReader(
            SqlSessionFactory sqlSessionFactory) {
        MyBatisCursorItemReader<ImportLine> reader = new MyBatisCursorItemReader<>();
        reader.setSqlSessionFactory(sqlSessionFactory);
        reader.setQueryId("com.example.batch.mapper.ImportLineMapper.findAll");
        return reader;
    }
    
    @Bean
    public Step processingStep(MyBatisCursorItemReader<ImportLine> reader,
                              ItemProcessor<ImportLine, ProcessResult> processor,
                              MyBatisBatchItemWriter<ProcessResult> writer) {
        return stepBuilderFactory.get("processingStep")
                .<ImportLine, ProcessResult>chunk(100)
                .reader(reader)
                .processor(processor)
                .writer(writer)
                .listener(stepMetricsListener)
                .faultTolerant()
                .skipLimit(100)
                .skip(Exception.class)
                .build();
    }
    
    @Bean
    public MyBatisBatchItemWriter<ProcessResult> processResultWriter(
            SqlSessionTemplate sqlSessionTemplate) {
        MyBatisBatchItemWriter<ProcessResult> writer = new MyBatisBatchItemWriter<>();
        writer.setSqlSessionTemplate(sqlSessionTemplate);
        writer.setStatementId("com.example.batch.mapper.ProcessResultMapper.insert");
        return writer;
    }
}
```

üìä 10. MyBatis Mapper XML

ImportLineMapper.xml

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" 
    "http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<mapper namespace="com.example.batch.mapper.ImportLineMapper">
    
    <select id="findAll" resultType="ImportLine">
        SELECT 
            record_id as recordId,
            data_field1 as dataField1,
            data_field2 as dataField2,
            amount,
            transaction_date as transactionDate,
            status
        FROM import_table 
        WHERE status = 'PENDING'
        ORDER BY record_id
    </select>
    
</mapper>
```

üìà 11. Main Application Class

BatchMonitoringApplication.java

```java
@SpringBootApplication
@EnableBatchProcessing
public class BatchMonitoringApplication implements CommandLineRunner {
    
    @Autowired
    private JobLauncher jobLauncher;
    
    @Autowired
    private Job dataProcessingJob;
    
    @Autowired
    private CustomBatchMetricsService metricsService;
    
    public static void main(String[] args) {
        SpringApplication.run(BatchMonitoringApplication.class, args);
    }
    
    @Override
    public void run(String... args) throws Exception {
        System.out.println("=== Spring Batch Monitoring Application Started ===");
        System.out.println("Actuator Endpoints available at: http://localhost:8080/actuator");
        System.out.println("Custom Metrics API available at: http://localhost:8080/api/metrics");
        
        // You can trigger jobs manually or via REST API
        if (args.length > 0 && "runJob".equals(args[0])) {
            JobParameters jobParameters = new JobParametersBuilder()
                    .addLong("timestamp", System.currentTimeMillis())
                    .toJobParameters();
            
            JobExecution execution = jobLauncher.run(dataProcessingJob, jobParameters);
            System.out.println("Job completed with status: " + execution.getStatus());
        }
    }
}
```

üìä 12. Accessing Metrics

Available Endpoints:

¬∑ Actuator Health: http://localhost:8080/actuator/health
¬∑ Actuator Metrics: http://localhost:8080/actuator/metrics
¬∑ Custom Batch Metrics: http://localhost:8080/api/metrics/custom
¬∑ Batch Summary: http://localhost:8080/api/metrics/batch/summary
¬∑ Detailed Health: http://localhost:8080/api/metrics/health/detailed

Sample Output from /api/metrics/custom:

```json
{
  "batch.jobs.total": 15,
  "batch.steps.total": 45,
  "batch.items.processed": 125000,
  "batch.items.read": 125000,
  "batch.items.written": 124500,
  "batch.items.skipped": 500,
  "batch.errors.total": 25,
  "batch.job.execution.time": 45600,
  "batch.step.execution.time": 123400,
  "memory.used": 256000000,
  "memory.max": 1024000000,
  "memory.free": 768000000
}
```

This implementation provides comprehensive monitoring without requiring Docker, Prometheus, or Grafana, using MyBatis for database operations and standard Spring Boot Actuator for metrics exposure!